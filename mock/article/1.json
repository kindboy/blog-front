{
    "code": 0,
    "message": "文章获取成功",
    "data": {
        "_id": "5c3b20fe57666419fe3d408c",
        "id": 64,
        "title": "Vue Property Decorator",
        "keyword": "nodejs",
        "descript": "\nNode.js 就不相同了，它使用了「非阻塞」与「事件驱动」模型，你可以把它想象成一个 Event Loop 循环，这个循环会一直跑。一个新的请求来了，Event Loop 接收这个请求，然后交给其他线程，比如查询数据库，然后响应一个 callback，接着接收其他请求，而不是等待数据库结果的返回。",
        "content": "> 为什么JavaScript中0.1+0.2不等于0.3，如何解决JavaScript中精度缺失的问题\n\n在大多数静态类型语言中都采用多种数据类型来保存数组，比如在C语言中我们有`Int`, `Long`, `Float`, `Double`这四种数据类型来分别保存4字节的整形，8字节的整形，4字节的浮点型和8字节的浮点型数字。而在Javascript中则只有一种number数据类型来保存数字，实际上Javascript中的number数据类型是基本符合 IEEE 754-2008 规定的双精度浮点数，类似于C语言的Double数据类型。而0.1+0.2不等于0.3的问题实际上在大部分使用浮点数的语言中都存在。\n\n要弄明白文章开头的Javascript精度缺失问题，我们首先就要从问题的源头-浮点数在计算机中的表示方法开始了解：\n\n## IEEE 754 双精度表示\n\n根据国际标准IEEE 754，任意一个二进制浮点数V可以表示成下面的形式：\n\n$$ V = (-1)^S \\times M \\times 2^E $$\n\n注：S代表符号位，当S=0时, V>0, 当S=1时, V<0；M代表有效数字，大于等于0， 小于2；E为指数位\n\n所有数字都可以表示为科学计数法，比如十进制的5表示为科学计数法就是$5 \\times 10^0$，用二进制表示就是：\n$$\n5 = 101_2 \\\\\n101_2 = 1.01_2 \\times 2^2 \\\\\n1.01_2 = (-1)^0 \\times 1.01_2 \\times 2^2\n$$\n那么代入公式可得 $S=0, M=1.01_2, E=2$。\n\nIEEE754标准规定64位的双精度浮点数在计算机中存储时，最高的1位为符号位S，接着11位表示指数E，剩余52位表示有效数字M。（对于32位单精度浮点数符号位占用一位，指数E占用8位，有效数字M占用23位）\n\n![](http://ww1.sinaimg.cn/large/005XqAn2ly1g4rlscx6bnj317i06ugly.jpg)\n\n到这里，你可能会觉得5是这样存储的：\n\n![](https://ws1.sinaimg.cn/large/005XqAn2ly1g4rlymu4g6j316206274k.jpg)\n\n但事实上，根据IEEE754规定，对于有效数字M和指数E的存储有一点特殊规定：\n\n所有数字都是科学计数法转化过来的，对于二进制的规范科学计数法，所有数字都可以表示为$1.xxxx... \\times 2^n$的形式，既然整数位始终都是1我们也就没有必要浪费一位来存储，只需要执行计算的时候硬件补回来即可，所以对于$1.02_2$我们实际上只保存$01$。\n\n对于指数E，在64位的双精度浮点数表示中，我们的指数位占用了11位来存储，可以表示的数字范围就是$0 \\leq E \\leq 2^{11} - 1$，但在科学计数法中指数是可能为负数的。所以为了表示负数，IEEE754标准规定，E表示的指数是使用真实值减去一个中间值得到的。对于双精度浮点数，这个中间值是1023，所以要表示$2^5$的指数，$E = 5 + 1023 = 1028$。\n\n最后，对于指数E还有几种特殊情况：\n\n（1）当指数位全部为$0$时，$E = 1 - 1023 = -1022$有效数字$M$不再加上整数位的$1$，这种情况表示$±0$，以及接近于$0$的很小的数字。\n（2）当指数位全为$1$时，如果有效数字M全为0，则表示**±Infinity**,如果M不全为0，这表示NaN。\n\n终上所述，我们数字5在计算机中的双精度浮点数表示就是：\n\n![](https://ws1.sinaimg.cn/large/005XqAn2ly1g4rnc3kan0j3161068aa7.jpg)\n\n## 0.1 + 0.2 不等于0.3\n\n现在再来看一开始说的$0.1 + 0.2 \\not= 0.3$。\n\n首先将$0.1, 0.2$表示为科学计数法：\n\n$$\n0.1 \\approx 1.1001100110011001100110011001100110011001100110011001100110011010 \\times 2^{-4} \\\\\n0.2 \\approx 1.1001100110011001100110011001100110011001100110011001100110011010 \\times 2^{-3}\n$$\n\n再将两个数转化为指数部分相同，再相加：\n\n$$\n2^{-3} \\times (0.110011001...1001101 + 1.10011001...10011010) \\\\\n2^{-3} \\times 10.0110011001100110011001100110011001100110011001100110011001100111 \\\\\n2^{-2} \\times 1.00110011001100110011001100110011001100110011001100110011001100111 \\\\\n$$\n\n最后的结果有效数字部分比52位多了一位，四舍五入为$1.0011001100110011001100110011001100110011001100110011001100110100$, 所以最后的表示为：\n\n![](https://ws1.sinaimg.cn/large/005XqAn2ly1g4ro1cxxugj315t05wglw.jpg)\n\n之所以最后计算的结果与我们的认知出现了偏差就是因为在计算的过程中，0.1和0.2在计算机中存储的就是一个四舍五入后的值，计算后的结果也经过了四舍五入，最终导致了与我们认知上的偏差。\n\n## 参考\n\n>* [Why 0.1+0.2 IS NOT equal to 0.3 and 9007199254740992 IS equal to 9007199254740993](https://blog.angularindepth.com/javascripts-number-type-8d59199db1b6)\n>* [浮点数的二进制表示](http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html)\n>* [IEEE 754 可视化](https://bartaz.github.io/ieee754-visualization/)\n",
        "type": 1,
        "thumb": "https://static.jkchao.cn/nodejs-new-pantone-black.png",
        "__v": 0,
        "meta": {
            "comments": 9,
            "likes": 23,
            "views": 521
        },
        "update_at": "2019-02-17T06:41:18.313Z",
        "create_at": "2019-01-13T11:29:02.509Z",
        "publish": 1,
        "state": 1,
        "tags": [
            {
                "_id": "59d6df5fc72f12628eea9425",
                "id": 6,
                "name": "Node.js",
                "descript": "运行与服务器端的 JavaScript",
                "__v": 0,
                "update_at": "2019-01-05T10:32:14.707Z",
                "sort": 13,
                "create_at": "2017-10-06T01:41:51.905Z"
            }
        ]
    }
}